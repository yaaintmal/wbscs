// index.js
const express = require('express');
const bodyParser = require('body-parser');
const admin = require('firebase-admin');
const { GoogleGenerativeAI } = require('@google/generative-ai');

const app = express();
const PORT = process.env.PORT || 3000; // Port für den Server

// WICHTIG: Die folgenden Variablen (__firebase_config, __app_id, __initial_auth_token)
// werden von der Canvas-Umgebung zur Laufzeit bereitgestellt.
// Für lokale Tests musst du sie manuell setzen (z.B. aus einer .env-Datei oder direkt hier).
// Beispiel für lokale Entwicklung:
/*
const __firebase_config = JSON.stringify({
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
    projectId: "YOUR_PROJECT_ID",
    storageBucket: "YOUR_PROJECT_ID.appspot.com",
    messagingSenderId: "YOUR_SENDER_ID",
    appId: "YOUR_APP_ID",
    measurementId: "YOUR_MEASUREMENT_ID",
    serviceAccount: require('./path/to/your/serviceAccountKey.json') // ACHTUNG: Produktionsbereitstellung sicher!
});
const __app_id = "your-canvas-app-id";
// const __initial_auth_token = "some-initial-token"; // Nicht direkt für Backend-Auth benötigt
*/

const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

// Initialisiere Firebase Admin SDK
// Stelle sicher, dass firebaseConfig.serviceAccount ein valides Service Account JSON-Objekt ist.
// In einer Produktionsumgebung sollte dies sicher über Umgebungsvariablen geladen werden.
if (!firebaseConfig || !firebaseConfig.projectId || !firebaseConfig.serviceAccount) {
    console.error("Firebase Admin Konfiguration unvollständig. Backend kann nicht gestartet werden.");
    // Hier könnte man einen Prozess.exit() aufrufen oder eine Fehlermeldung senden
    // Aber für die Canvas-Umgebung gehen wir davon aus, dass es zur Laufzeit korrekt gesetzt wird.
} else {
    try {
        admin.initializeApp({
            credential: admin.credential.cert(firebaseConfig.serviceAccount),
            projectId: firebaseConfig.projectId // projectId ist wichtig für Admin SDK
        });
        console.log("Firebase Admin SDK erfolgreich initialisiert.");
    } catch (error) {
        console.error("Fehler bei der Initialisierung von Firebase Admin SDK:", error);
    }
}


const db = admin.firestore();

// API-Schlüssel für Gemini (wird zur Laufzeit injiziert)
const genAI = new GoogleGenerativeAI(""); // API-Schlüssel wird zur Laufzeit injiziert
const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-preview-05-20" });


// Definierte Kategorien (müssen mit Frontend übereinstimmen)
const CATEGORIES = [
  "Handwerk_Heimwerken", "Recht_Buerokratie", "Garten_Landwirtschaft",
  "Haushalt_Technik", "Gesundheit_Ernahrung"
];

// Middleware
app.use(bodyParser.json());

// Middleware zur Authentifizierung (vereinfacht für dieses Beispiel)
// In einer echten Anwendung würde hier die Verifizierung des Firebase ID Tokens stattfinden.
const authenticateUser = async (req, res, next) => {
    try {
        const idToken = req.headers.authorization?.split('Bearer ')[1];
        if (!idToken) {
            return res.status(401).send('Nicht autorisiert: Kein Token vorhanden.');
        }
        // Überprüfe das Firebase ID Token
        const decodedToken = await admin.auth().verifyIdToken(idToken);
        req.user = decodedToken; // User-Daten im Request speichern
        next();
    } catch (error) {
        console.error('Fehler bei der Authentifizierung:', error);
        return res.status(403).send('Nicht autorisiert: Ungültiges Token.');
    }
};

// --- API-Endpunkte ---

// POST /api/questions/ask
// Authentifizierung erforderlich
app.post('/api/questions/ask', authenticateUser, async (req, res) => {
  const { title, description, location } = req.body;
  const userId = req.user.uid; // Die User ID aus dem authentifizierten Token

  if (!userId || !title || !description || !location || !location.city || !location.country) {
    return res.status(400).send({ message: 'Fehlende Daten.' });
  }

  try {
    // 1. KI-Analyse der Frage
    const prompt = `Kategorisiere die folgende Frage in eine der Kategorien: ${CATEGORIES.join(', ')}. Extrahiere zusätzlich bis zu 5 Schlüsselwörter. Antworte im JSON-Format: {"category": "KATEGORIE", "keywords": ["KW1", "KW2", "KW3", "KW4", "KW5"]}. Frage: "${title} ${description}"`;

    let chatHistory = [];
    chatHistory.push({ role: "user", parts: [{ text: prompt }] });

    const payload = {
        contents: chatHistory,
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: {
                type: "OBJECT",
                properties: {
                    "category": { "type": "STRING", "enum": CATEGORIES },
                    "keywords": {
                        "type": "ARRAY",
                        "items": { "type": "STRING" },
                        "maxItems": 5 // Max. 5 Schlüsselwörter
                    }
                },
                "propertyOrdering": ["category", "keywords"]
            }
        }
    };

    const apiKey = ""; // Wird zur Laufzeit injiziert
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

    const aiResponse = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    });
    const result = await aiResponse.json();

    let category = "Allgemein"; // Fallback-Kategorie
    let keywords = [];

    if (result.candidates && result.candidates.length > 0 &&
        result.candidates[0].content && result.candidates[0].content.parts &&
        result.candidates[0].content.parts.length > 0) {
      const jsonString = result.candidates[0].content.parts[0].text;
      try {
        const aiAnalysis = JSON.parse(jsonString);
        if (aiAnalysis.category && CATEGORIES.includes(aiAnalysis.category)) {
          category = aiAnalysis.category;
        } else {
          console.warn(`KI wies unbekannte Kategorie zu: ${aiAnalysis.category}. Setze auf Fallback.`);
        }
        keywords = Array.isArray(aiAnalysis.keywords) ? aiAnalysis.keywords.slice(0, 5) : [];
      } catch (parseError) {
        console.error("Fehler beim Parsen der KI-Antwort:", parseError);
      }
    } else {
      console.warn("KI-Antwort hat unerwartetes Format oder ist leer.");
    }

    // 2. Finde potenzielle Experten (im öffentlichen Bereich der App-ID)
    const expertsRef = db.collection(`artifacts/${appId}/public/data/users`);
    // Filter nach Ort und Kompetenz-Score
    let expertQuery = expertsRef
        .where('location.city', '==', location.city)
        .where(`competencies.${category}.score`, '>', 50) // Beispiel: Mindest-Score für Weiterleitung

    const expertSnapshot = await expertQuery.get();
    let potentialExperts = [];
    expertSnapshot.forEach(doc => {
        potentialExperts.push({ id: doc.id, score: doc.data().competencies[category].score || 0 });
    });

    // Sortiere nach Score für die Auswahl der besten Experten
    potentialExperts.sort((a, b) => b.score - a.score);

    // 3. Priorisiere und wähle die Top-Experten basierend auf Fragesteller-Priorität
    const askerDoc = await db.collection(`artifacts/${appId}/public/data/users`).doc(userId).get();
    const askerData = askerDoc.data();
    const isAskerPrioritized = askerData && askerData.prioritized === true; // explizit 'true' prüfen

    const numExpertsToAssign = isAskerPrioritized ? 10 : 5; // Beispiel: Priorität = mehr Empfänger
    const assignedExperts = potentialExperts.slice(0, numExpertsToAssign).map(e => e.id);

    // 4. Frage in Firestore speichern
    const newQuestionRef = await db.collection(`artifacts/${appId}/public/data/questions`).add({
      title,
      description,
      askerId: userId,
      category,
      keywords,
      status: 'open',
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      assignedExperts // Speichert, an wen die Frage primär gerichtet wurde
    });

    // 5. Benachrichtige Experten (Dies erfordert Firebase Cloud Messaging - FCM)
    // Wenn FCM implementiert ist, würden hier die Geräte-Tokens der Experten abgefragt
    // und Push-Nachrichten gesendet. Beispiel:
    assignedExperts.forEach(async expertId => {
        const expertDoc = await db.collection(`artifacts/${appId}/public/data/users`).doc(expertId).get();
        const expertDeviceToken = expertDoc.data()?.deviceToken; // Annahme: Token im User-Dokument
        if (expertDeviceToken) {
            // Hier würde die FCM-Nachricht über admin.messaging().send() gesendet
            console.log(`FCM: Sende Nachricht an ${expertId} mit Token ${expertDeviceToken}`);
            // Beispiel:
            // admin.messaging().send({
            //     token: expertDeviceToken,
            //     notification: {
            //         title: 'Neue Frage in ExpertSphere!',
            //         body: `Eine neue Frage in der Kategorie "${category}" wartet auf deine Expertise.`
            //     },
            //     data: {
            //         questionId: newQuestionRef.id,
            //         category: category
            //     }
            // }).then(response => {
            //     console.log('Nachricht erfolgreich gesendet:', response);
            // }).catch(error => {
            //     console.error('Fehler beim Senden der Nachricht:', error);
            // });
        }
    });

    res.status(201).send({ message: 'Frage erfolgreich gestellt', questionId: newQuestionRef.id });

  } catch (error) {
    console.error('Fehler beim Stellen der Frage:', error);
    res.status(500).send({ message: 'Fehler beim Stellen der Frage.', error: error.message });
  }
});

// POST /api/answers/submit
// Authentifizierung erforderlich
app.post('/api/answers/submit', authenticateUser, async (req, res) => {
  const { questionId, answerText } = req.body;
  const userId = req.user.uid;

  if (!userId || !questionId || !answerText) {
    return res.status(400).send({ message: 'Fehlende Daten.' });
  }

  try {
    const questionRef = db.collection(`artifacts/${appId}/public/data/questions`).doc(questionId);
    const questionDoc = await questionRef.get();

    if (!questionDoc.exists) {
      return res.status(404).send({ message: 'Frage nicht gefunden.' });
    }

    // Stellen Sie sicher, dass der User nicht der Fragesteller ist, um eigene Fragen zu beantworten
    if (questionDoc.data().askerId === userId) {
      return res.status(403).send({ message: 'Sie können Ihre eigene Frage nicht beantworten.' });
    }

    await db.collection(`artifacts/${appId}/public/data/answers`).add({
      questionId,
      answererId: userId,
      answerText,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      isHelpful: false // Wird vom Fragesteller gesetzt
    });

    // Benachrichtige den Fragesteller über neue Antwort (FCM erforderlich)
    const askerId = questionDoc.data().askerId;
    const askerDoc = await db.collection(`artifacts/${appId}/public/data/users`).doc(askerId).get();
    const askerDeviceToken = askerDoc.data()?.deviceToken; // Annahme: Token im User-Dokument
    if (askerDeviceToken) {
        console.log(`FCM: Sende Nachricht an Fragesteller ${askerId}`);
        // admin.messaging().send({ ... });
    }

    res.status(201).send({ message: 'Antwort erfolgreich gesendet.' });

  } catch (error) {
    console.error('Fehler beim Senden der Antwort:', error);
    res.status(500).send({ message: 'Fehler beim Senden der Antwort.', error: error.message });
  }
});

// POST /api/answers/rate
// Authentifizierung erforderlich
app.post('/api/answers/rate', authenticateUser, async (req, res) => {
  const { answerId, questionId } = req.body;
  const reviewerId = req.user.uid; // Der User, der bewertet (muss der Fragesteller sein)

  if (!answerId || !questionId || !reviewerId) {
    return res.status(400).send({ message: 'Fehlende Daten.' });
  }

  try {
    const answerRef = db.collection(`artifacts/${appId}/public/data/answers`).doc(answerId);
    const answerDoc = await answerRef.get();

    if (!answerDoc.exists) {
      return res.status(404).send({ message: 'Antwort nicht gefunden.' });
    }
    if (answerDoc.data().isHelpful) {
        return res.status(400).send({ message: 'Antwort wurde bereits als hilfreich markiert.' });
    }

    const questionRef = db.collection(`artifacts/${appId}/public/data/questions`).doc(questionId);
    const questionDoc = await questionRef.get();

    if (!questionDoc.exists) {
        return res.status(404).send({ message: 'Zugehörige Frage nicht gefunden.' });
    }
    if (questionDoc.data().askerId !== reviewerId) {
      return res.status(403).send({ message: 'Nur der Fragesteller kann diese Antwort bewerten.' });
    }
    if (questionDoc.data().helpfulAnswerId) {
        return res.status(400).send({ message: 'Diese Frage hat bereits eine hilfreiche Antwort.' });
    }

    await db.runTransaction(async (transaction) => {
      // 1. Antwort als hilfreich markieren
      transaction.update(answerRef, { isHelpful: true });

      // 2. Punkte vergeben und Abzeichen prüfen
      const answererId = answerDoc.data().answererId;
      const questionCategory = questionDoc.data().category;
      const answererRef = db.collection(`artifacts/${appId}/public/data/users`).doc(answererId);
      const answererDoc = await transaction.get(answererRef);

      if (!answererDoc.exists) {
        throw new Error('Antwortender Nutzer nicht gefunden.');
      }

      const currentCompetencies = answererDoc.data().competencies || {};
      const categoryData = currentCompetencies[questionCategory] || { score: 0, badges: [] };
      
      const newScore = categoryData.score + 10; // Beispiel: 10 Punkte pro hilfreicher Antwort
      let updatedBadges = [...categoryData.badges];

      // Beispiel-Abzeichenlogik
      if (newScore >= 100 && !updatedBadges.includes("Lehrling")) {
        updatedBadges.push("Lehrling");
      }
      if (newScore >= 300 && !updatedBadges.includes("Experte")) {
        updatedBadges.push("Experte");
      }
      if (newScore >= 500 && !updatedBadges.includes("Meister")) {
        updatedBadges.push("Meister");
      }

      // Aktualisiere den Kompetenz-Score und die Abzeichen
      transaction.update(answererRef, {
        [`competencies.${questionCategory}`]: {
          score: newScore,
          badges: updatedBadges
        }
      });

      // 3. Status der Frage auf "answered" setzen und hilfreichste Antwort vermerken
      transaction.update(questionRef, {
        status: 'answered',
        helpfulAnswerId: answerId
      });

      // Optional: Prioritäts-Status des Users prüfen/aktualisieren
      // Könnte hier oder als separate Cron-Job-Funktion ausgeführt werden
      const totalScore = Object.values(answererDoc.data().competencies || {}).reduce((sum, comp) => sum + comp.score, 0) + 10; // Gesamtsumme
      if (totalScore >= 1000 && !answererDoc.data().prioritized) { // Beispiel: Schwellwert für Priorität
        transaction.update(answererRef, { prioritized: true });
      } else if (totalScore < 1000 && answererDoc.data().prioritized) {
        transaction.update(answererRef, { prioritized: false });
      }

    });

    res.status(200).send({ message: 'Antwort als hilfreich markiert und Punkte vergeben.' });

  } catch (error) {
    console.error('Fehler beim Bewerten der Antwort:', error);
    res.status(500).send({ message: 'Fehler beim Bewerten der Antwort.', error: error.message });
  }
});

// GET /api/user/:userId/profile
// Authentifizierung erforderlich
app.get('/api/user/:userId/profile', authenticateUser, async (req, res) => {
    const { userId } = req.params;
    if (req.user.uid !== userId) {
        return res.status(403).send({ message: 'Nicht autorisiert: Zugriff nur auf das eigene Profil.' });
    }

    try {
        const userRef = db.collection(`artifacts/${appId}/public/data/users`).doc(userId);
        const userDoc = await userRef.get();

        if (!userDoc.exists) {
            return res.status(404).send({ message: 'Benutzerprofil nicht gefunden.' });
        }
        res.status(200).json(userDoc.data());
    } catch (error) {
        console.error('Fehler beim Abrufen des Profils:', error);
        res.status(500).send({ message: 'Fehler beim Abrufen des Profils.', error: error.message });
    }
});


// GET /api/user/:userId/questions/assigned
// Authentifizierung erforderlich
app.get('/api/user/:userId/questions/assigned', authenticateUser, async (req, res) => {
  const { userId } = req.params;
  if (req.user.uid !== userId) {
      return res.status(403).send({ message: 'Nicht autorisiert: Zugriff nur auf eigene zugewiesene Fragen.' });
  }

  try {
    const questionsRef = db.collection(`artifacts/${appId}/public/data/questions`);
    // WICHTIG: 'orderBy' erfordert Indexe in Firestore. Für 'array-contains' und 'orderBy' zusammen
    // ist oft ein Composite Index nötig. Ohne Indexe kann dies zu Fehlern führen.
    // Für dieses Beispiel lassen wir orderBy erst einmal weg, um keine Index-Fehler zu provozieren,
    // oder die Sortierung findet im Frontend statt.
    const q = questionsRef
      .where('assignedExperts', 'array-contains', userId)
      .where('status', '==', 'open');
      // .orderBy('createdAt', 'desc'); // Kommentiert, da Index-Management außerhalb des Scopes liegt

    const snapshot = await q.get();
    const assignedQuestions = [];
    snapshot.forEach(doc => {
      assignedQuestions.push({ id: doc.id, ...doc.data() });
    });

    res.status(200).json(assignedQuestions);
  } catch (error) {
    console.error('Fehler beim Abrufen der zugewiesenen Fragen:', error);
    res.status(500).send({ message: 'Fehler beim Abrufen der zugewiesenen Fragen.', error: error.message });
  }
});

// GET /api/user/:userId/cockpit
// Authentifizierung erforderlich
app.get('/api/user/:userId/cockpit', authenticateUser, async (req, res) => {
  const { userId } = req.params;
  if (req.user.uid !== userId) {
      return res.status(403).send({ message: 'Nicht autorisiert: Zugriff nur auf das eigene Cockpit.' });
  }

  try {
    const userDocRef = db.collection(`artifacts/${appId}/public/data/users`).doc(userId);
    const userDoc = await userDocRef.get();

    if (!userDoc.exists) {
      return res.status(404).send({ message: 'Benutzerprofil nicht gefunden.' });
    }

    const userData = userDoc.data();
    const totalScore = Object.values(userData.competencies || {}).reduce((sum, comp) => sum + (comp.score || 0), 0);

    // Beispiel: Zugriff nur für "Top-Experten" (Gesamt-Score > 500)
    if (totalScore < 500) {
      return res.status(403).send({ message: 'Zugriff verweigert. Nicht genügend Expertise für das Experten-Cockpit.' });
    }

    // Prioritäts-Status (wird im Frontend angezeigt)
    const prioritizedStatus = userData.prioritized || false;

    // Top 3 Kategorien des Users (nach Score)
    const userTopCategories = Object.entries(userData.competencies || {})
                                  .sort(([,a],[,b]) => (b.score || 0) - (a.score || 0))
                                  .slice(0, 3)
                                  .map(([key]) => key);

    // Trend-Analyse: Häufig gestellte offene Fragen in den Top-Kategorien des Users (der letzten 7 Tage)
    const trendingQuestions = [];
    if (userTopCategories.length > 0) {
      // WICHTIG: 'in'-Abfragen sind auf 10 Werte beschränkt. Wenn mehr Kategorien, mehrere Queries nötig.
      // Erfordert außerdem Indexe: composite index on (category ASC, createdAt DESC, status ASC)
      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
      const qRef = db.collection(`artifacts/${appId}/public/data/questions`)
                     .where('category', 'in', userTopCategories)
                     .where('status', '==', 'open')
                     .where('createdAt', '>', sevenDaysAgo)
                     .orderBy('createdAt', 'desc') // WICHTIG: Erfordert Index
                     .limit(10);
      const snapshot = await qRef.get();
      snapshot.forEach(doc => trendingQuestions.push({ id: doc.id, ...doc.data() }));
    }

    res.status(200).json({
      prioritizedStatus: prioritizedStatus,
      topCategories: userTopCategories,
      trendingQuestions: trendingQuestions
    });

  } catch (error) {
    console.error('Fehler beim Abrufen des Experten-Cockpits:', error);
    res.status(500).send({ message: 'Fehler beim Abrufen des Experten-Cockpits.', error: error.message });
  }
});


// Server starten
app.listen(PORT, () => {
  console.log(`ExpertSphere Backend läuft auf Port ${PORT}`);
  console.log(`Zugriff für Frontend unter http://localhost:${PORT}`);
});
